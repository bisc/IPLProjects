import Robot_Task_Types.*;
import tasks_view_map0_wempty.*;
// this spec is NOT valid with this view (because the view doesn't use task type 2 for empties): 
//import tasks_manual_simple_empty.*;
    
use view TaskLibrary.fullspeed as tasklib;
set tasks: Task;

bfun distinct(int, int, int, int, int, int, int, int) -> bool;    
bfun abs (int) -> int; 
  
//use model prism_noturns_nocharge_nospeed_map0(INITIAL_LOCATION, TARGET_LOCATION, INITIAL_BATTERY);
stvar l: int;
stvar s: int; 
stvar b: int;
 
// assumption: monotonicity of missions, so no point in checking budgets too small or too big
// assumption: empty missions have their start = end

// Expected 696 models with err_cons = 1 (232 models with err_cons = 0)
// Needs more validation

forall err_prism : {2} | // does not affect verification times
forall err_cons: {0} | // affects verification times proportionally 
forall t1: tasks | forall t2: tasks | forall t3: tasks | forall t4: tasks | forall t5: tasks | forall t6: tasks | forall t7: tasks |
// cohesive path: 
	t1::end_loc = t2::start_loc & t2::end_loc = t3::start_loc &
		t3::end_loc = t4::start_loc & t4::end_loc = t5::start_loc & 
		t5::end_loc = t6::start_loc & t6::end_loc = t7::start_loc & 
		// no circularities/shortcuts, and the tail of the path can be empty: 
		(
			// either all tasks are different 
			(   
				distinct (t1::start_loc, t2::start_loc, t3::start_loc, t4::start_loc, t5::start_loc, t6::start_loc, t7::start_loc, t7::end_loc) &
				t1::task_type = 0 & t2::task_type = 0 & t3::task_type = 0 & t4::task_type = 0 & 
				t5::task_type = 0 & t6::task_type = 0 & t7::task_type = 0 
			) ||
			(   
				distinct (t1::start_loc, t2::start_loc, t3::start_loc, t4::start_loc, t5::start_loc, t6::start_loc, t7::start_loc) &
				t1::task_type = 0 & t2::task_type = 0 & t3::task_type = 0 & t4::task_type = 0 & 
				t5::task_type = 0 & t6::task_type = 0 & 
				t7::task_type = 2
			) ||
			(   
				distinct (t1::start_loc, t2::start_loc, t3::start_loc, t4::start_loc, t5::start_loc, t6::start_loc) &
				t1::task_type = 0 & t2::task_type = 0 & t3::task_type = 0 & t4::task_type = 0 & t5::task_type = 0 & 
				t6::task_type = 2 &	t7::task_type = 2
			) || 
			(   
				distinct (t1::start_loc, t2::start_loc, t3::start_loc, t4::start_loc, t5::start_loc) &
				t1::task_type = 0 & t2::task_type = 0 & t3::task_type = 0 & t4::task_type = 0 & 
				t5::task_type = 2 & t6::task_type = 2 &	t7::task_type = 2
			) || 
			( 
				distinct (t1::start_loc, t2::start_loc, t3::start_loc, t4::start_loc) &
				t1::task_type = 0 & t2::task_type = 0 & t3::task_type = 0 & 
				t4::task_type = 2 &	t5::task_type = 2 & t6::task_type = 2 &	t7::task_type = 2
			) ||
			( 
				distinct (t1::start_loc, t2::start_loc, t3::start_loc) &
				t1::task_type = 0 & t2::task_type = 0 & 
				t3::task_type = 2 &	t4::task_type = 2 &	t5::task_type = 2 & t6::task_type = 2 &	t7::task_type = 2
			) || 
			( // or one non-empty task
				distinct (t1::start_loc, t2::start_loc) &
				t1::task_type = 0 & t2::task_type = 2 & t3::task_type = 2 & t4::task_type = 2 
				&	t5::task_type = 2 & t6::task_type = 2 &	t7::task_type = 2
			)
	// exists such a minimal budget 
	) ->  (exists ebmin: int |  
	// robot can find its way to the finish on this budget 
	// the budget fits into the battery  
	ebmin >= 0 & ebmin <= 32560 - err_prism - 1  &
		(// minimal budget minus prism error (= 2 here) minus 1 should always fail
			(P max=? [  
				//(G s = 1) & 
				// no shortcuts
				(F l = t2::start_loc) & (F l = t3::start_loc) &	(F l = t4::start_loc) & (F l = t5::start_loc) &
				(F l = t6::start_loc) & (F l = t7::start_loc) &
				// in order
				((l = t1::start_loc) U (l = t2::start_loc U (l = t3::start_loc U (l = t4::start_loc U (l = t5::start_loc U 
					(l = t6::start_loc U (l = t7::start_loc U ( l = t7::end_loc & b > 0))))))))
			]{|t1::start_loc, t7::end_loc, ebmin - err_prism - 1 |} = 0) &
			// minimal budget plus prism error (=2 here) plus 1 should always succeed
			(P max=? [  
				//(G s = 1) & 
				// no shortcuts
				(F l = t2::start_loc) & (F l = t3::start_loc) &	(F l = t4::start_loc) & (F l = t5::start_loc) &
				(F l = t6::start_loc) & (F l = t7::start_loc) &
				// in order
				((l = t1::start_loc) U (l = t2::start_loc U (l = t3::start_loc U (l = t4::start_loc U (l = t5::start_loc U 
					(l = t6::start_loc U (l = t7::start_loc U ( l = t7::end_loc & b > 0))))))))
				// constraint above guarantees no overflow over max bat
			]{|t1::start_loc, t7::end_loc, ebmin + err_prism + 1 |} = 1) &
			// min budget & regression are within consistency tolerance (= 1 here) 
			abs(ebmin - (t1::energy + t2::energy + t3::energy + t4::energy + t5::energy + 
					t6::energy + t7::energy + 1)) <= err_cons
		));
		
